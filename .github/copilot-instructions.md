<!-- Autogenerated guidance for AI coding agents working on the Newbie shell project. -->
# Copilot instructions for the `newbie` shell project

These instructions help AI coding agents be productive in this repository. They are intentionally concise and specific to patterns and workflows observed in `Cargo.toml` and `src/main.rs`.

1) Big-picture architecture
- Single binary Rust project (`Cargo.toml`, edition 2021) implementing an interactive shell / REPL in `src/main.rs`.
- Major responsibilities live in `src/main.rs`: command parsing, a keyword registry (`KEYWORDS`), a streaming file-processing architecture, variable namespaces (user/global/config/system/process/network), and execution backends for built-in actions (`&show`, `&run`, `&copy`, `&move`, `&delete`, `&vars`, `&set`, `&get`).
- Design rationale you must keep in mind:
  - Memory-constrained streaming: the code avoids heap-growing `Vec` for large data and uses fixed-size arrays, circular buffers, and iterators. Preserve that pattern when editing parsing or file-processing code.
  - Two-phase flow: parse tokens into a Command struct, then execute. Many handlers only mutate `Command` and return control; follow this separation when adding new keywords.

2) Key files and symbols to inspect
- `Cargo.toml` — features: optional compression crates behind `compression` feature (flate2, bzip2, xz2, zstd). Don't add new runtime dependencies without checking feature gating.
- `src/main.rs` — single large file; primary symbols:
  - `Command` struct: central execution plan built by handlers.
  - `KEYWORDS` static: maps keyword strings (e.g. `&show`, `&run`, `&set`) to handlers. Add handlers by registering entries here.
  - `parse_and_execute_line`, `parse_tokens_fixed_size`: central parsing; respects fixed-size buffers and token limits (`MAX_TOKENS_PER_LINE`, `MAX_ARGS_PER_KEYWORD`).
  - `execute_*` functions: streaming file readers (e.g. `execute_show_first_lines`, `execute_show_last_lines`) and external execution helpers (`execute_external_command`, `execute_bash_command`).

3) Project conventions and non-obvious patterns
- Memory safety / streaming-first: avoid allocating large Vecs for file lines or tokens. Use the existing fixed-size arrays or iterators. If you need to increase a limit, change the `const` values at the top (e.g. `MAX_TOKENS_PER_LINE`, `MAX_LAST_LINES`) and reason about stack vs heap impact.
- Tokenization and keywords: tokens beginning with `&` and not containing `.` are treated as keywords. Variable references use `&v.`, `&system.`, `&process.`, `&network.`, `&global.`, `&config.` — treat these syntactically as variable refs, not keywords.
- Two-stage handlers: keyword handlers take a slice of args and mutate the `Command`; many return `ExecutionResult::Continue` (modifier) vs `Stop` (terminal). When adding handlers, follow this pattern.
- Silent-by-default execution: `&run` and external command execution runs silently unless `&show` or `command.display_output` is set. Also `command.capture_output` is used for assignments. Preserve these booleans when changing execution behavior.
- Admin / sudo behavior: `&admin` sets `command.admin_mode` and runs commands under `sudo`. Handlers must clear or respect sudo (`sudo -k`) where present.
- History file: `get_history_path()` uses `dirs::data_dir()` and stores history in `newbie/history.txt`. Preserve history handling in `init_editor`/`save_history` edits.

4) Build, test and debug workflows
- Standard build: use the workspace root where `Cargo.toml` lives.

  - Build (debug): cargo build
  - Run REPL locally: cargo run --quiet
  - Run a quick check: cargo check

- Features: compression support is opt-in. To enable compression features in local runs or tests, use:

  cargo build --features compression

- When modifying external command execution or `&run` behavior, test with small, repeatable commands (e.g. `&run BASH echo hi`, `&show README.md &first 3`).

5) Integration points and external dependencies
- Uses `rustyline` (interactive editing + history). Editing the REPL loop should preserve rustyline usage patterns.
- Uses external system tools at runtime: `rsync`, `sudo`, `hostname`, shell from `SHELL` env var. Assume they exist on developer machines; add guards if you make features portable.
- Optional compression crates are behind a feature flag; don't assume they are available unless `--features compression` is passed.

6) Adding a new keyword (step-by-step)
 - Implement a handler with signature fn(&[&str], &mut Command) -> Result<ExecutionResult, Box<dyn Error>>.
 - Register the handler in `KEYWORDS` with the `&name` string.
 - The handler should only mutate `Command` fields; return `Continue` for modifiers and `Stop` if the handler completes the Command build.
 - Ensure parsing limits (MAX_ARGS_PER_KEYWORD) won't be exceeded or document/increase them if necessary.

7) Examples taken from code
- Variable assignment: `&v.foo = bar` or inferred `&v.foo bar` are auto-detected by `detect_set_context` and converted into an implicit `&set` prefix.
- Run with display: `&show &run BASH ls -la` — `&show` enables `command.display_output` so `execute_bash_command` will inherit stdio.
- Streaming last N lines: `&show file.txt &last 10` uses a fixed-size circular buffer limited by `MAX_LAST_LINES`.

8) When to ask for human review
- Any change that increases fixed-size limits (e.g., MAX_TOKENS_PER_LINE, MAX_LAST_LINES) should include a short rationale and memory usage estimate.
- Adding new runtime dependencies or enabling network/IO features needs a maintainer sign-off.

If anything here is unclear or you want me to expand examples (e.g., add a template handler or small unit tests), tell me which sections to iterate on.

---
Generated based on `Cargo.toml` and `src/main.rs` (primary source of truth).
